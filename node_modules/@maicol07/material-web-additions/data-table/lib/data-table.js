import { __decorate } from "tslib";
import '@material/web/linearprogress/linear-progress.js';
import '@material/web/iconbutton/filled-icon-button.js';
import '@material/web/select/outlined-select.js';
import '@material/web/select/select-option.js';
import '../data-table-footer.js';
import { html } from 'lit';
import { property, query, queryAssignedElements } from 'lit/decorators.js';
import { attributes, MDCDataTableFoundation } from '@material/data-table';
import { cssClasses, messages, SortValue } from '@material/data-table/constants.js';
import { IconButton } from '@material/web/iconbutton/lib/icon-button.js';
import { BaseElement } from '@material/mwc-base';
export class DataTable extends BaseElement {
    constructor() {
        super(...arguments);
        /**
         * Enable/disable pagination.
         */
        this.paginated = false;
        /**
         * JSON array with the page sizes to be used in the pagination and shown as page size select options.
         */
        this.pageSizes = '[10, 25, 100]';
        /**
         * Label to show before the page size select.
         */
        this.pageSizesLabel = 'Rows per page:';
        /**
         * Index of the first row to be shown on the current page.
         */
        this.firstRowOfPage = 1;
        /** @internal */
        this.pageSizesArray = JSON.parse(this.pageSizes);
        /**
         * Size of the current page.
         */
        this.currentPageSize = this.pageSizesArray[0];
        /**
         * Index of the last row to be shown on the current page.
         */
        this.lastRowOfPage = this.currentPageSize;
        /**
         * Label pattern to show after the page size select that indicates the current rows shown in the page.
         * It should contain the following parameters: `:firstRow`, `:lastRow`, `:totalRows`
         */
        this.paginationTotalLabel = ':firstRow-:lastRow of :totalRows';
        /**
         * Whether the loading indicator is active.
         */
        this.inProgress = false;
        /** @internal */
        this.mdcRoot = this.tableElement;
        /** @internal */
        // @ts-ignore (TypeScript bug)
        this.mdcFoundationClass = MDCDataTableFoundation;
        this.columnFilters = new Map();
        /** @internal */
        this.rowCallback = (e) => this.mdcFoundation.handleRowCheckboxChange(e);
        /** @internal */
        this.headerRowCallback = () => this.mdcFoundation.handleHeaderRowCheckboxChange();
        /** @internal */
        this.filterColumnCallback = (e) => {
            const event = e;
            // Don't filter if the column is using custom filtering
            if (event.detail.customFiltering) {
                return;
            }
            const { text, column } = event.detail;
            if (text === '') {
                this.columnFilters.delete(column);
            }
            else {
                this.columnFilters.set(column, text);
            }
            for (const row of this.rows) {
                row.hidden = true;
            }
            let rowsToShow = this.rows;
            for (let [column, filterText] of this.columnFilters) {
                rowsToShow = this.rows.filter((row) => {
                    const index = this.columns.indexOf(column);
                    let cellText = row.cells[index].textContent ?? '';
                    if (!event.detail.caseSensitive) {
                        cellText = cellText.toLowerCase();
                        filterText = filterText.toLowerCase();
                    }
                    return cellText.search(filterText) !== -1;
                });
            }
            this.showRows(rowsToShow);
            /**
             * Event emitted when the data table has been filtered.
             *
             * Event detail: `FilteredDetail`;
             */
            this.dispatchEvent(new CustomEvent('filtered', {
                detail: {
                    column: event.detail.column,
                    text,
                    caseSensitive: event.detail.caseSensitive,
                    columnIndex: this.columns.indexOf(column)
                }
            }));
        };
        this.sortColumnCallback = (e) => {
            const event = e;
            const { column, isDescending } = event.detail;
            // Don't sort if the column is using custom sorting
            if (!event.detail.customSorting) {
                this.inProgress = true;
                for (const col of this.columns.filter((col) => col !== column && col.sortable)) {
                    col.sorted = false;
                    col.sortedDescending = false;
                }
                const cells = this.rows.map((row) => row.cells[this.columns.indexOf(column)]);
                cells.sort((a, b) => {
                    let aValue = a.textContent;
                    let bValue = b.textContent;
                    if (column.type === 'numeric') {
                        aValue = Number.parseFloat(aValue);
                        bValue = Number.parseFloat(bValue);
                    }
                    if (!isDescending) {
                        const temporary = aValue;
                        aValue = bValue;
                        bValue = temporary;
                    }
                    if (typeof aValue === 'string' && typeof bValue === 'string') {
                        return aValue.localeCompare(bValue);
                    }
                    return aValue < bValue ? -1 : (aValue > bValue ? 1 : 0);
                });
                // this.rows = cells.map((cell) => cell.parentElement as DataTableRow);
                for (const cell of cells) {
                    const row = cell.parentElement;
                    row.parentElement.append(row);
                }
                this.inProgress = false;
                column.sorted = true;
            }
            column.withSortButton = true;
            /**
             * Event emitted when the data table has been filtered.
             *
             * Event detail: `FilteredDetail`;
             */
            this.dispatchEvent(new CustomEvent('sorted', {
                detail: {
                    column: event.detail.column,
                    isDescending,
                }
            }));
        };
    }
    /** @internal */
    get headerCheckboxRow() {
        return this.columns.filter((column) => column.checkbox !== undefined)[0];
    }
    /** @internal */
    get headerCheckbox() {
        return this.headerCheckboxRow?.checkbox;
    }
    render() {
        return html `
      <div class="mdc-data-table">
        <div class="mdc-data-table__table-container">
          <div class="mdc-data-table__table" aria-label="${this.ariaLabel}" role="table">
            <div class="mdc-data-table__head" role="rowgroup">
              <div class="mdc-data-table__header-row" role="row">
                <slot name="header-cell" @slotchange=${this.onHeaderCellSlotChange}></slot>
              </div>
            </div>
            <div class="mdc-data-table__content" role="rowgroup">
              <slot name="row" @slotchange=${() => this.requestUpdate()}></slot>
            </div>
          </div>
        </div>

        ${this.renderPagination()}

        <slot name="footer"></slot>

        <div class="mdc-data-table__progress-indicator">
          <div class="mdc-data-table__scrim"></div>
          <md-linear-progress indeterminate class="mdc-data-table__linear-progress" role="progressbar"
                               aria-label="Data is being loaded..."></md-linear-progress>
        </div>
      </div>
    `;
    }
    onHeaderCellSlotChange() {
        this.requestUpdate();
        const sortColumn = this.columns.find((column) => column.sortable && column.sorted);
        if (sortColumn) {
            sortColumn.onSortButtonClicked(new CustomEvent('icon-button-toggle-change', { detail: { selected: !sortColumn.sortedDescending } }));
        }
    }
    renderPagination() {
        if (this.paginated) {
            const initialPageLabel = this.firstRowOfPage < 1 ? 1 : this.firstRowOfPage;
            const lastPageLabel = this.lastRowOfPage > this.rows.length ? this.rows.length : this.lastRowOfPage;
            return html `
        <md-data-table-footer>
          <div class="mdc-data-table__pagination-trailing">
            <div class="mdc-data-table__pagination-rows-per-page">
              <div class="mdc-data-table__pagination-rows-per-page-label">
                ${this.pageSizesLabel}
              </div>
              
              <md-outlined-select
                  type="number"
                  class="mdc-data-table__pagination-rows-per-page-select"
                  value="${this.currentPageSize}"
                  @input=${this.onPageSizeSelected}>
                  ${this.pageSizesArray.map((size) => html `
                  <md-select-option value="${size}" headline="${size}">${size}</md-select-option>
                  `)}
              </md-outlined-select>
            </div>

            <div class="mdc-data-table__pagination-navigation">
              <div class="mdc-data-table__pagination-total">
                ${this.renderTemplate(this.paginationTotalLabel, {
                'firstRow': initialPageLabel,
                'lastRow': lastPageLabel,
                'totalRows': this.rows.length,
            })}
              </div>
              <md-filled-icon-button class="mdc-data-table__pagination-button"
                               data-page="first"
                               ?disabled=${this.firstRowOfPage <= 1}
                               @click=${this.onPaginationButtonClicked}>
                <slot name="pagination-first-button-icon">
                  <md-icon slot="icon">first_page</md-icon>
                </slot>
              </md-filled-icon-button>
              <md-filled-icon-button class="mdc-data-table__pagination-button"
                               data-page="previous"
                               ?disabled=${this.firstRowOfPage <= 1}
                               @click=${this.onPaginationButtonClicked}>
                <slot name="pagination-previous-button-icon">
                  <md-icon>chevron_left</md-icon>
                </slot>
              </md-filled-icon-button>
              <md-filled-icon-button class="mdc-data-table__pagination-button"
                               data-page="next"
                               ?disabled=${this.lastRowOfPage >= this.rows.length}
                               @click=${this.onPaginationButtonClicked}>
                <slot name="pagination-next-button-icon">
                  <md-icon>chevron_right</md-icon>
                </slot>
              </md-filled-icon-button>
              <md-filled-icon-button class="mdc-data-table__pagination-button"
                               data-page="last"
                               ?disabled=${this.lastRowOfPage >= this.rows.length}
                               @click=${this.onPaginationButtonClicked}>
                <slot name="pagination-last-button-icon">
                  <md-icon>last_page</md-icon>
                </slot>
              </md-filled-icon-button>
            </div>
          </div>
        </div>
      `;
        }
        return '';
    }
    onPageSizeSelected(e) {
        // const select = e.target as Autocomplete;
        this.currentPageSize = Number.parseInt(e.target.value);
        this.paginate('first');
    }
    onPaginationButtonClicked(event) {
        let button = event.target;
        if (!(button instanceof IconButton)) {
            button = button.closest('.mdc-data-table__pagination-button');
        }
        const action = button.dataset['page'];
        this.paginate(action);
    }
    paginate(action = 'current') {
        this.pageSizesArray = JSON.parse(this.pageSizes);
        if (!this.pageSizesArray.includes(this.currentPageSize)) {
            this.currentPageSize = this.pageSizesArray[0];
        }
        if (this.paginated) {
            this.hideRows();
            switch (action) {
                case 'first':
                    this.firstRowOfPage = 1;
                    this.lastRowOfPage = this.currentPageSize;
                    break;
                case 'previous':
                    this.firstRowOfPage -= this.currentPageSize;
                    this.lastRowOfPage -= this.currentPageSize;
                    break;
                case 'next':
                    this.firstRowOfPage += this.currentPageSize;
                    this.lastRowOfPage += this.currentPageSize;
                    break;
                case 'last':
                    this.firstRowOfPage = this.rows.length - this.currentPageSize + 1;
                    this.lastRowOfPage = this.rows.length;
                    break;
            }
            const rowsToShow = this.rows.slice(this.firstRowOfPage - 1, this.lastRowOfPage);
            this.showRows(rowsToShow);
        }
    }
    firstUpdated() {
        super.firstUpdated();
        this.paginate('first');
    }
    updated(_changedProperties) {
        super.updated(_changedProperties);
        for (const row of this.rows) {
            row.removeEventListener('selected', this.rowCallback);
            row.addEventListener('selected', this.rowCallback);
            row.setAttribute('density', this.density);
        }
        for (const column of this.columns) {
            column.removeEventListener('filter', this.filterColumnCallback);
            column.addEventListener('filter', this.filterColumnCallback);
            column.removeEventListener('sort', this.sortColumnCallback);
            column.addEventListener('sort', this.sortColumnCallback);
            column.setAttribute('density', this.density);
        }
        this.headerCheckboxRow?.removeEventListener('checked', this.headerRowCallback);
        this.headerCheckboxRow?.addEventListener('checked', this.headerRowCallback);
        this.paginate();
        if (this.inProgress) {
            this.mdcFoundation?.showProgress();
        }
        else {
            this.mdcFoundation?.hideProgress();
        }
        this.mdcFoundation?.layout();
    }
    createAdapter() {
        return {
            addClass: (className) => {
                if (className === cssClasses.IN_PROGRESS) {
                    this.tableElement.classList.add(cssClasses.IN_PROGRESS);
                }
            },
            removeClass: (className) => {
                if (className === cssClasses.IN_PROGRESS) {
                    this.tableElement.classList.remove(cssClasses.IN_PROGRESS);
                }
            },
            addClassAtRowIndex: (rowIndex, className) => {
                if (className === cssClasses.ROW_SELECTED) {
                    this.rows[rowIndex].selected = true;
                }
            },
            getRowCount: () => this.rows.length,
            getRowElements: () => this.rows,
            getRowIdAtIndex: (rowIndex) => this.rows?.[rowIndex].id ?? null,
            getRowIndexByChildElement: (el) => this.rows.findIndex((row) => row.contains(el)),
            getSelectedRowCount: () => this.rows.filter((row) => row.selected).length,
            isCheckboxAtRowIndexChecked: (rowIndex) => this.rows[rowIndex].selected,
            isHeaderRowCheckboxChecked: () => this.headerCheckbox?.checked ?? false,
            isRowsSelectable: () => this.headerCheckbox !== undefined ||
                this.rows.filter((row) => row.checkboxCell !== undefined).length > 0,
            notifyRowSelectionChanged: (data) => {
                /**
                 * Event emitted when row checkbox is checked or unchecked.
                 *
                 * Event detail: `RowSelectionChangedDetail`.
                 */
                this.dispatchEvent(new CustomEvent('rowSelectionChanged', {
                    detail: {
                        row: this.rows[data.rowIndex],
                        rowIndex: data.rowIndex,
                        selected: data.selected,
                    }
                }));
            },
            notifySelectedAll: () => {
                /**
                 * Event emitted when header row checkbox is checked.
                 */
                this.dispatchEvent(new CustomEvent('selectedAll'));
            },
            notifyUnselectedAll: () => {
                /**
                 * Event emitted when header row checkbox is unchecked.
                 */
                this.dispatchEvent(new CustomEvent('unselectedAll'));
            },
            notifyRowClick: (detail) => {
                /**
                 * Event emitted when a row has been checked or unchecked.
                 *
                 * Event detail: `RowClickEventData`.
                 */
                this.dispatchEvent(new CustomEvent('rowClick', { detail }));
            },
            registerHeaderRowCheckbox: () => {
            },
            registerRowCheckboxes: () => {
            },
            removeClassAtRowIndex: (rowIndex, className) => {
                if (className === cssClasses.ROW_SELECTED) {
                    this.rows[rowIndex].selected = false;
                }
            },
            setAttributeAtRowIndex: (rowIndex, attr, value) => {
                const row = this.rows[rowIndex];
                if (row) {
                    row.setAttribute(attr, value);
                    if (attr === attributes.ARIA_SELECTED) {
                        row.selected = value === 'true';
                    }
                }
            },
            setHeaderRowCheckboxChecked: (checked) => {
                if (this.headerCheckbox) {
                    this.headerCheckbox.checked = checked;
                }
            },
            setHeaderRowCheckboxIndeterminate: (indeterminate) => {
                if (this.headerCheckbox) {
                    this.headerCheckbox.indeterminate = indeterminate;
                }
            },
            setRowCheckboxCheckedAtIndex: (rowIndex, checked) => {
                const row = this.rows[rowIndex];
                if (row) {
                    row.selected = checked;
                }
            },
            getHeaderCellCount: () => this.columns.length,
            getHeaderCellElements: () => this.columns,
            getAttributeByHeaderCellIndex: (columnIndex, attribute) => this.columns[columnIndex].getAttribute(attribute),
            setAttributeByHeaderCellIndex: (columnIndex, attribute, value) => {
                this.columns[columnIndex].setAttribute(attribute, value);
            },
            setClassNameByHeaderCellIndex: (columnIndex, className) => {
                const attributesMapping = {
                    [cssClasses.HEADER_CELL_SORTED]: 'sorted',
                    [cssClasses.HEADER_CELL_SORTED_DESCENDING]: 'sortedDescending'
                };
                this.columns[columnIndex].toggleAttribute(attributesMapping[className], true);
            },
            removeClassNameByHeaderCellIndex: (columnIndex, className) => {
                const attributesMapping = {
                    [cssClasses.HEADER_CELL_SORTED]: 'sorted',
                    [cssClasses.HEADER_CELL_SORTED_DESCENDING]: 'sortedDescending'
                };
                this.columns[columnIndex].toggleAttribute(attributesMapping[className], false);
            },
            notifySortAction: (data) => {
                /**
                 * Event emitted when a column has been sorted.
                 *
                 * Event detail: `SortActionEventDetail`.
                 */
                this.dispatchEvent(new CustomEvent('sorted', { detail: data }));
            },
            getTableContainerHeight: () => this.tableContainerElement.getBoundingClientRect().height,
            getTableHeaderHeight: () => this.headerRowElement.getBoundingClientRect().height,
            setProgressIndicatorStyles: (styles) => {
                this.progressIndicator.style.top = styles.top;
                this.progressIndicator.style.height = styles.height;
            },
            setSortStatusLabelByHeaderCellIndex: (columnIndex, sortValue) => {
                const column = this.columns[columnIndex];
                if (column.sortable) {
                    const mappings = {
                        [SortValue.ASCENDING]: messages.SORTED_IN_ASCENDING,
                        [SortValue.DESCENDING]: messages.SORTED_IN_DESCENDING,
                    };
                    // @ts-ignore
                    column.sortButton.ariaLabel = mappings[sortValue];
                }
            }
        };
    }
    renderTemplate(template, params) {
        for (const [key, value] of Object.entries(params)) {
            template = template.replace(`:${key}`, value);
        }
        return template;
    }
    hideRows(rows = this.rows) {
        for (const row of rows) {
            row.hidden = true;
            row.classList.remove('without-bottom-border');
        }
    }
    showRows(rows = this.rows) {
        for (const row of rows) {
            row.hidden = false;
        }
        // Add bottom border to the last row
        rows.slice(-1)[0]?.classList.add('without-bottom-border');
    }
}
__decorate([
    property({ type: Boolean, reflect: true })
], DataTable.prototype, "paginated", void 0);
__decorate([
    property({ type: String, reflect: true })
], DataTable.prototype, "pageSizes", void 0);
__decorate([
    property({ type: String, reflect: true })
], DataTable.prototype, "pageSizesLabel", void 0);
__decorate([
    property({ type: Number, reflect: true })
], DataTable.prototype, "firstRowOfPage", void 0);
__decorate([
    property({ type: Number, reflect: true })
], DataTable.prototype, "currentPageSize", void 0);
__decorate([
    property({ type: Number, reflect: true })
], DataTable.prototype, "lastRowOfPage", void 0);
__decorate([
    property({ type: String })
], DataTable.prototype, "paginationTotalLabel", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], DataTable.prototype, "inProgress", void 0);
__decorate([
    property({ type: String, reflect: true })
], DataTable.prototype, "density", void 0);
__decorate([
    queryAssignedElements({ slot: 'header-cell', selector: 'md-data-table-column' })
], DataTable.prototype, "columns", void 0);
__decorate([
    queryAssignedElements({ slot: 'row', selector: 'md-data-table-row' })
], DataTable.prototype, "rows", void 0);
__decorate([
    query('.mdc-data-table')
], DataTable.prototype, "tableElement", void 0);
__decorate([
    query('.mdc-data-table__table-container')
], DataTable.prototype, "tableContainerElement", void 0);
__decorate([
    query('.mdc-data-table__header-row')
], DataTable.prototype, "headerRowElement", void 0);
__decorate([
    query('.mdc-data-table__progress-indicator')
], DataTable.prototype, "progressIndicator", void 0);
//# sourceMappingURL=data-table.js.map